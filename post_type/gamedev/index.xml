<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gamedev on NODRAGEM GAMES</title>
    <link>https://nodragem.github.io/Blog/post_type/gamedev/</link>
    <description>Recent content in Gamedev on NODRAGEM GAMES</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 Geoffrey MÃ©gardon</copyright>
    <lastBuildDate>Sun, 18 Feb 2018 17:14:08 +0100</lastBuildDate>
    <atom:link href="/Blog/post_type/gamedev/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Simulating Lag and Drop when Debugging Multiplayer Games</title>
      <link>https://nodragem.github.io/Blog/post/gamedev/18022018_clumsy/</link>
      <pubDate>Sun, 18 Feb 2018 17:14:08 +0100</pubDate>
      
      <guid>https://nodragem.github.io/Blog/post/gamedev/18022018_clumsy/</guid>
      <description>

&lt;h2 id=&#34;debugging-multiplayer-games-locally&#34;&gt;Debugging multiplayer games locally&lt;/h2&gt;

&lt;p&gt;These days, I&amp;rsquo;m playing around with making online multiplayer prototype games.&lt;/p&gt;

&lt;p&gt;Most of the time, when we debug our video games for online multiplayer, we run a local server on &lt;code&gt;localhost&lt;/code&gt;. This server acts as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a file server - sending the game files to the client,&lt;/li&gt;
&lt;li&gt;a game server - transferring information between clients, authorizing transactions, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can debug your code logic on server side and client side very easily nowadays. For instance, I use VS Code, with NodeJS to debug the server side and the Chrome debugger plug-in to debug the client side.&lt;/p&gt;

&lt;p&gt;However, once your game works perfectly with your local server, it only means that it works perfectly with &lt;em&gt;perfect network condition!&lt;/em&gt; You are still miles away from having a game working in real world network conditions.&lt;/p&gt;

&lt;p&gt;When released, your multiplayer code will have to deal with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;variable delays of communication between clients and server,&lt;/li&gt;
&lt;li&gt;variable number of dropped messages/packages.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Although software like Unity offers to simulate this kind of disruptions, we are not all and/or always using Unity :D ! I am using Phaser right now. After some research I found a little piece of software allowing to simulate real-word network condition locally, so I thought I will share.&lt;/p&gt;

&lt;h2 id=&#34;clumsy-an-utility-to-simulate-broken-network&#34;&gt;Clumsy an utility to simulate broken network&lt;/h2&gt;

&lt;p&gt;This piece of software is named &lt;code&gt;clumsy&lt;/code&gt; and can be found &lt;a href=&#34;https://jagt.github.io/clumsy/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;. According to their website:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;clumsy makes your network condition on Windows significantly worse, but in a managed and interactive manner.&lt;/p&gt;
&lt;/blockquote&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/18022018_clumsy/clumsy.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;What&amp;rsquo;s nice about it is that it does not require any installation and works out-of-the box. When unzipped, &lt;code&gt;clumsy&lt;/code&gt; sits next to a file &lt;code&gt;config.txt&lt;/code&gt; where you can specify exactly which part of the network you want to disrupt.&lt;/p&gt;

&lt;p&gt;For instance, if I host my server on &lt;code&gt;localhost:5000&lt;/code&gt;, I can make a configuration that disrupt the access to &lt;code&gt;localhost:5000&lt;/code&gt;. To do so, I added the following in &lt;code&gt;config.txt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTML5 games: outbound and tcp.DstPort == 5000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that, when you open Clumsy, you will be able to select the configuration &lt;code&gt;HTML5 games&lt;/code&gt; from the droplist menu.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/18022018_clumsy/clumsy_html5games.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Note that the configuration &lt;code&gt;localhost ipv4 all&lt;/code&gt; does roughlythe same as my config except that it disrupts &lt;em&gt;any&lt;/em&gt; local hosts.&lt;/p&gt;

&lt;h2 id=&#34;experimenting-with-delayed-and-dropped-packages&#34;&gt;Experimenting with Delayed and Dropped Packages&lt;/h2&gt;

&lt;p&gt;To give you a better idea of how network dirupstion translates into your game, I tested &lt;code&gt;clumsy&lt;/code&gt; on a prototype I made recently. I used a client authoritative network with two clients and one server to keep things simple.&lt;/p&gt;

&lt;p&gt;What I mean by Client Authoritative is that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Client 1 (on the top) applies the input of the player without delay,&lt;/li&gt;
&lt;li&gt;Client 1 sends the position of the charactor to the server,&lt;/li&gt;
&lt;li&gt;The server transmits the position to Client 2&lt;/li&gt;
&lt;li&gt;Client 2 (on the bottom) applies the position&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, the server does not nothing but transmitting information between Client 1 and Client 2. Obviously, in practice, you would not do that to avoid cheating, but that &amp;rsquo;s ok for our example.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/18022018_clumsy/all_0lag_0drop.gif&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Without delay and with 0% of dropped packages, the game works like a charm. However, we have no feel of what the players will be experiencing.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/18022018_clumsy/all_1000lag_0drop.gif&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;When we add some delays (1000 ms), the game still works, and we can test how the game feels with the server-to-client delay.  However, &lt;code&gt;clumsy&lt;/code&gt;&amp;rsquo;s delays seem to be &lt;em&gt;fixed&lt;/em&gt;, as opposed to be &lt;em&gt;random&lt;/em&gt;, which is most probably the case in real network.&lt;/p&gt;

&lt;p&gt;With &lt;em&gt;random&lt;/em&gt; delays, you would experience bugs if your code relies on messages arriving to the server in the order they have been sent. For instance, something like that would lead to bugs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[Client Side]

this._socket.emit(&#39;spawning_points_request&#39;);
this._socket.emit(&#39;new_player_request&#39;);

self = this;
this._socket.on(&#39;spawning_points&#39;, function(data){
            self.spawning_points = data.spawning_points;
        });

this._socket.on(&#39;new_player&#39;, function(data){
            self.addPlayer(data.player, self.spawning_positions[0]);
        });

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this code, the spawning positions must be received from the server before that the new player is received. While we requested the spawning positions first, a real network would not guarantee that you will receive the spawning points first. If I understand well, in &lt;code&gt;clumsy&lt;/code&gt;, you can emulate that behaviour with the &lt;code&gt;Out of order&lt;/code&gt; option.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/18022018_clumsy/all_50lag_20drop.gif&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Finally, when we add dropped packages, things can become a big mess. In our example, Client 2 (bottom) always succeeds to catch up with Client 1 (top)  because Client 1 sends the &lt;em&gt;position&lt;/em&gt; of the character and not the change in position.&lt;/p&gt;

&lt;p&gt;However, if your code relies on sending changes in state (i.e. delta method) or on sending an important message, you may experience bugs as these messages are dropped. For instance, in this simple example, I only send once the message to request a new player to the server. If it does not reach the server, I need to reload the page, until it does!&lt;/p&gt;

&lt;p&gt;Hope you will have fun debugging with &lt;code&gt;clumsy&lt;/code&gt;. If you know other useful tools for debugging multiplayer online game, let us know in the comments below!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Game Release: Catch the Crow</title>
      <link>https://nodragem.github.io/Blog/post/gamedev/catchthecrown_release/</link>
      <pubDate>Fri, 14 Apr 2017 12:43:08 +0100</pubDate>
      
      <guid>https://nodragem.github.io/Blog/post/gamedev/catchthecrown_release/</guid>
      <description>

&lt;h2 id=&#34;release-and-then-move-on&#34;&gt;Release and then move on &amp;hellip;&lt;/h2&gt;

&lt;p&gt;Finally! After 3 years of uneven and chaotic development (partly due to a PhD), it feels like that&amp;rsquo;s the right time to finalize and ship my first video game.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/prabbit_winning_lowres.gif&#34; alt=&#34;How it feels like to ship a game!&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        How it feels like to ship a game!
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Catch the Crown is the first game I made with libGDX. It is a multiplayer arena platform game. My pride is that it feels like I am shipping an actual game: it can be run, played and it delivers fun (to my friends at least!).
You can download it here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Windows, portable version (&lt;a href=&#34;https://github.com/Nodragem/Catch-the-Crown/releases/download/v0.9-alpha/catchthecrown_win32.zip&#34; target=&#34;_blank&#34;&gt;zip-file&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Linux, portable version (&lt;a href=&#34;https://github.com/Nodragem/Catch-the-Crown/releases/download/v0.9-alpha/catchthecrown_linux32.zip&#34; target=&#34;_blank&#34;&gt;zip-file&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Mac OS, portable version (&lt;a href=&#34;https://github.com/Nodragem/Catch-the-Crown/releases/download/v0.9-alpha/catchthecrown_mac.zip&#34; target=&#34;_blank&#34;&gt;zip-file&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please find more details about customization on the &lt;a href=&#34;https://nodragem.github.io/Blog/Blog/project/catchthecrown/&#34; target=&#34;_blank&#34;&gt;Project Page&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-story&#34;&gt;The Story&lt;/h2&gt;

&lt;p&gt;I made up most of the story and gameplay with one of my best friends on a 7 hours road trip to Edinburgh :). The basic idea is that in the tribe of the Prabbits - half parrot/half rabbit creatures - four teenagers are undertaking their &amp;ldquo;Coming-of-Age&amp;rdquo; ritual.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/doing_nothing.gif&#34; alt=&#34;Three teenager Prabbits chilling out before the Coming-of-Age ritual...&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Three teenager Prabbits chilling out before the Coming-of-Age ritual...
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;the-gameplay&#34;&gt;The Gameplay&lt;/h2&gt;

&lt;p&gt;The Prabbits are spawned on a map where there is one Crown while a timer is running. Once the Crown is picked up by a Prabbit, coins, diamonds, and rubies appear across the level. Only the Prabbit with the Crown can collect them. When collected part of the money goes to the Prabbit&amp;rsquo;s gold chest while the other part goes in the Crown itself.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/timer.gif&#34; width=&#34;100%&#34;/&gt;
    &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/catch_crown.gif&#34; width=&#34;100%&#34;/&gt;
    &lt;figcaption&gt;
        Only the Prabbit with the Crown can collect treasures
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;A competition starts between Prabbits as everyone wants to catch the Crown and be able to collect gold. When the timer ends, it is the richer Prabbit that wins the turn; players need to win 3 turns to win the tournament and be declared King of the Tournament (see Screenshot1).&lt;/p&gt;

&lt;h2 id=&#34;the-character-actions&#34;&gt;The Character Actions&lt;/h2&gt;

&lt;p&gt;The Prabbits have several ways to hurt each other. They can throw lances, slap each other, pick up another Prabbit and make a lethal throw. To slap someone increases their fatigue (fatigue marks on his head), which will increase the respawning time the next time they die. Time is precious - the longer a player is waiting to respawn, the less they can collect gold or change the outcome of the game.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/spear_and_slap.gif&#34; alt=&#34;Spear, Slap, Trap Combo! I was alone recording, that&amp;#39;s why Red is not moving :P&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Spear, Slap, Trap Combo! I was alone recording, that&amp;#39;s why Red is not moving :P
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;what-was-not-implemented&#34;&gt;What was not implemented&lt;/h2&gt;

&lt;p&gt;Originally, Catch The Crown was thought to be a cooperative and competitive 2D platform game. A Shaman would have explained the competition rules to the teenager Prabbits. During a round, the players would have a common gold chest in addition to their own. The next level would be unlocked only if the common chest reaches a certain amount of Gold (you can still see this chest in the GUI).&lt;/p&gt;

&lt;p&gt;The levels would have been designed to force cooperative behavior to get more common Gold. Furthermore, the Shaman would summon creatures against which the Prabbits need to fight in cooperation. Thus, to win a tournament would encourage a competitive gameplay, while to unlock a new level would encourage a cooperative gameplay.&lt;/p&gt;

&lt;p&gt;Maybe later I will do a sequel where I will implement more of the stuff I wanted originally. In any case, I will probably come back with new levels for this version of the game. Hope you enjoy the game!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
