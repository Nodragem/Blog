<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Recent Posts on Yargeoff&#39;s Blog</title>
    <link>https://nodragem.github.io/Blog/post/index.xml</link>
    <description>Recent content in Recent Posts on Yargeoff&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 Geoffrey MÃ©gardon</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/Blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Game Release: Catch the Crow</title>
      <link>https://nodragem.github.io/Blog/post/gamedev/catchthecrown_release/</link>
      <pubDate>Fri, 14 Apr 2017 12:43:08 +0100</pubDate>
      
      <guid>https://nodragem.github.io/Blog/post/gamedev/catchthecrown_release/</guid>
      <description>

&lt;h2 id=&#34;release-and-then-move-on&#34;&gt;Release and then move on &amp;hellip;&lt;/h2&gt;

&lt;p&gt;Finally! After 3 years of uneven and chaotic development (partly due to a PhD, more details &lt;a href=&#34;No page found with path or logical name &#34;blog/post.md&#34;.
&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;), it feels like that&amp;rsquo;s the right time to finalize and ship my first video game.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/prabbit_winning_lowres.gif&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;How it feels like to ship a game!&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Catch the Crown is the first game I made with libGDX. It is a multiplayer arena platform game. My pride is that it feels like I am shipping an actual game: it can be run, played and it delivers fun (to my friends at least!).
You can download it here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Windows, portable version (&lt;a href=&#34;https://github.com/Nodragem/Catch-the-Crown/releases/download/v0.9-alpha/catchthecrown_win32.zip&#34; target=&#34;_blank&#34;&gt;zip-file&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Linux, portable version (&lt;a href=&#34;https://github.com/Nodragem/Catch-the-Crown/releases/download/v0.9-alpha/catchthecrown_linux32.zip&#34; target=&#34;_blank&#34;&gt;zip-file&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Mac OS, portable version (&lt;a href=&#34;https://github.com/Nodragem/Catch-the-Crown/releases/download/v0.9-alpha/catchthecrown_mac.zip&#34; target=&#34;_blank&#34;&gt;zip-file&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please find more details about customization on the &lt;a href=&#34;https://nodragem.github.io/Blog/Blog/project/catchthecrown/&#34; target=&#34;_blank&#34;&gt;Project Page&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-story&#34;&gt;The Story&lt;/h2&gt;

&lt;p&gt;I made up most of the story and gameplay with one of my best friends on a 7 hours road trip to Edinburgh :). The basic idea is that in the tribe of the Prabbits - half parrot / half rabbit creatures - four teenagers are undertaking their &amp;ldquo;Coming-of-Age&amp;rdquo; ritual.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/doing_nothing.gif&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Three teenager Prabbits chilling out before the Coming-of-Age ritual...&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;the-gameplay&#34;&gt;The Gameplay&lt;/h2&gt;

&lt;p&gt;The Prabbits are spawned on a map where there is one Crown while a timer in running. Once the Crown is picked up by a Prabbit, coins, diamonds and rubies appear across the level. Only the Prabbit with the Crown can collect them. When collected part of the money goes to the Prabbit&amp;rsquo;s gold chest while the other part goes in the Crown itself.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/timer.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/catch_crown.gif&#34; width=&#34;100%&#34;/&gt;
    &lt;figcaption&gt;
        &lt;h4&gt;Only the Prabbit with the Crown can collect treasures&lt;/h4&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;A competition starts between Prabbits as everyone wants to catch the Crown and be able to collect gold. When the timer ends, it is the richer Prabbit that wins the turn; players need to win 3 turns to win the tournament and be declared King of the Tournament (see Screenshot1).&lt;/p&gt;

&lt;h2 id=&#34;the-character-actions&#34;&gt;The Character Actions&lt;/h2&gt;

&lt;p&gt;The Prabbits have several ways to hurt each other. They can throw lances, slap each other, pick up another Prabbit and make a lethal throw. To slap someone increase their fatigue (fatigue marks on his head), which will increase the respawning time the next time they die. Time is precious - the longer a player is waiting to respawn, the less they can collect gold or change the outcome of the game.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/gamedev/catchthecrown_release/spear_and_slap.gif&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Spear, Slap, Trap Combo! I was alone recording, that&amp;#39;s why Red is not moving :P&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;what-was-not-implemented&#34;&gt;What was not implemented&lt;/h2&gt;

&lt;p&gt;Originally, Catch The Crown was thought to be a cooperative and competitive 2D platform game. A Shaman would have explained the competitive rules to the teenager Prabbits. During a round, the players would have a common gold chest in addition to their own. The next level would be unlocked only if the common chest reaches a certain amount of Gold (you can still see this chest in the GUI).&lt;/p&gt;

&lt;p&gt;The levels would have been designed to force cooperative behaviour to get more common Gold. Furthermore, the Shaman would summon creatures against which the Prabbits need to fight in cooperation. Thus, to win a tournament would encourage a competitive gameplay, while to unlock a new level would encourage a cooperative gameplay.&lt;/p&gt;

&lt;p&gt;Maybe later I will do a sequel where I will implement more of the stuff I wanted originally. In any case, I will probably come back with new levels for this version of the game. Hope you enjoy the game!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generate Data From an Old Figure</title>
      <link>https://nodragem.github.io/Blog/post/research/analyseExtractedData/</link>
      <pubDate>Sun, 12 Mar 2017 21:02:50 +0000</pubDate>
      
      <guid>https://nodragem.github.io/Blog/post/research/analyseExtractedData/</guid>
      <description>

&lt;h2 id=&#34;data-extraction-with-webplotdigitizer&#34;&gt;Data extraction with WebPlotDigitizer&lt;/h2&gt;

&lt;p&gt;Recently, I was looking for generating stochastically fake saccade durations. Few articles show the main sequence in term of saccade duration against saccade magnitude (i.e. amplitude) for micro-saccades and I found this data from Troncoso et al. (2008) after some search.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/main_sequence.png&#34; width=&#34;500px&#34; height=&#34;500px&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Data from Troncoso, X. G., Macknik, S. L., &amp;amp; Martinez-Conde, S. (2008). Microsaccades counteract perceptual filling-in. Journal of Vision, 8(14):15, 1-9&lt;/em&gt; [ARVO is the copyright holder]&lt;/p&gt;

&lt;p&gt;There are two main problem though:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;there is many data points while the picture quality is quite poor,&lt;/li&gt;
&lt;li&gt;as the plot is in logscale, it might be hard to get an eyeball estimation of the regression line.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;WebPlotDigitizer (&lt;a href=&#34;http://arohatgi.info/WebPlotDigitizer/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;) is a data extractor that, among other things, allows us to calibrate the axis of the figure to extract in logspace. I tried it on Troconso et al.&amp;rsquo;s figure, without real hope of obtaining something decent because of the jped compression (my real hope was to manually draw a regression line in that jpeg fog).&lt;/p&gt;

&lt;p&gt;Here are the steps, recorded with ScreenToGif.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/webplotdigitizer.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The result is quite impressive when considering the picture quality. Here is what I obtained with the automatic extraction! Let see how this looks like once exported in CSV and plotted in R:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df1 &amp;lt;- read.csv(&amp;quot;extraction1.csv&amp;quot;, header = FALSE) 
setnames(df1, c(&#39;amplitude&#39;, &#39;duration&#39;))
head(df1, 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    amplitude duration
## 1 0.07355096 6.124430
## 2 0.08775247 5.467178
## 3 0.08825364 6.549086
## 4 0.08875767 5.453267
## 5 0.08901076 6.557844
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dim(df1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 5725    2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot(df1$amplitude, df1$duration, xlim=c(0.01, 2), ylim=c(1, 30),
     main=&#39;df1&#39;, pch=&#39;.&#39; , log=&amp;quot;xy&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That is very impressive for a data extraction from a jpeg fog. WebPlotDigitizer is not extracting &amp;ldquo;real&amp;rdquo; data points (which are almost invisible on this Figure), but still the density of the data points seems to correctly estimates the density of the original data. This should be enough to compute a good estimate of the regression line of the mean duration and of its standard deviation. So now, let us try to compute these regression lines and make a saccade duration generator.&lt;/p&gt;

&lt;h2 id=&#34;compute-the-regression-model&#34;&gt;Compute the Regression model&lt;/h2&gt;

&lt;p&gt;We should start with finding the regression line in logspace.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df1$log_duration &amp;lt;- log(df1$duration)
df1$log_amplitude &amp;lt;- log(df1$amplitude)
log.model &amp;lt;- lm( log_duration ~ log_amplitude, data=df1)
new &amp;lt;- data.frame(log_amplitude = seq(min(df1$log_amplitude), max(df1$log_amplitude), 0.01))
y_values &amp;lt;- predict(log.model, new, interval=&amp;quot;predict&amp;quot;)
plot(df1$log_amplitude, df1$log_duration,
     main=&#39;df1&#39;, pch=&#39;.&#39;)
lines(new$log_amplitude, y_values[,1], lwd=2, col=&#39;red&#39;)
lines(new$log_amplitude, y_values[,2], lwd=2, col=&#39;red&#39;)
lines(new$log_amplitude, y_values[,3], lwd=2, col=&#39;red&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the linear space, we get this pretty curve and increasing standard deviation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot(df1$amplitude, df1$duration,
     main=&#39;df1&#39;, pch=&#39;.&#39;)
lines(exp(new$log_amplitude), exp(y_values[,1]), lwd=2, col=&#39;red&#39;)
lines(exp(new$log_amplitude), exp(y_values[,2]), lwd=2, col=&#39;red&#39;)
lines(exp(new$log_amplitude), exp(y_values[,3]), lwd=2, col=&#39;red&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;extract-the-equations&#34;&gt;Extract the equations&lt;/h2&gt;

&lt;p&gt;To be able to generate data from the regression, we must extract the equations that describes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the mean duration of saccades according to their amplitude,&lt;/li&gt;
&lt;li&gt;the standard deviation according to their amplitude.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That is a bit more complicated as usual because of the logspace, but it is feasible.&lt;/p&gt;

&lt;h3 id=&#34;estimate-the-equation-of-the-mean&#34;&gt;Estimate the equation of the mean&lt;/h3&gt;

&lt;p&gt;It is easy to get the coefficients from the regression line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;b = log.model$coefficients[[1]]
a = log.model$coefficients[[2]]

x = new$log_amplitude
reg_eq = a
y = a*x + b

plot(df1$log_amplitude, df1$log_duration,
     main=&#39;df1&#39;, pch=&#39;.&#39;)
lines(x, y, lwd=2, col=&#39;red&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let pass the regression line in linear space. We got:&lt;/p&gt;

&lt;p&gt;$$
y_{log} = a.x_{log} + b \&lt;br /&gt;
$$&lt;/p&gt;

&lt;p&gt;and:
$$
y_{lin} = exp(y_{log})\&lt;br /&gt;
$$
$$
x_{lin} = exp(x_{log})\&lt;br /&gt;
$$
 So that, when combined, that gives:
$$
y_{lin} = exp(ax_{log} + b) &lt;br /&gt;
$$
$$
= exp(ax_{log}) . exp(b) &lt;br /&gt;
$$
$$
= exp(x_{log})^a . exp(b) &lt;br /&gt;
$$
$$
= x_{lin}^a . exp(b)
$$&lt;/p&gt;

&lt;p&gt;With we should be able to plot the regression line in linear space:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cart_x = seq(min(df1$amplitude), max(df1$amplitude), 0.01)
cart_y = (cart_x^a) * exp(b)
plot(df1$amplitude, df1$duration,
     main=&#39;df1&#39;, pch=&#39;.&#39;)
lines(cart_x, cart_y, lwd=2, col=&#39;red&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Yeah! we got it. Now let us extract the equation for the standard deviation.&lt;/p&gt;

&lt;h3 id=&#34;estimate-the-standard-deviations&#34;&gt;Estimate the standard deviations&lt;/h3&gt;

&lt;p&gt;In logspace, we get a standard deviation that is rather flat, althought there may be a small irregularity on the right hand side.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;par(mfrow=c(1,2))
log_sd = abs(log.model$residuals)
# log_sd = log.model$residuals
plot(df1$amplitude, log_sd, ylim=c(-1, 1), xlim=c(0, 1))
sd_change = rollapply(log_sd, width = 200, FUN = median, fill = NA)
plot(df1$amplitude, sd_change, ylim= c(-1, 1 ), xlim=c(0, 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, to find the change in variance in the cartesian space is not as simple as taking the exponential of the logspace&amp;rsquo;s variance.&lt;/p&gt;

&lt;p&gt;First, let us compute the standard deviation and its trends in the cartesian space.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# remember that:
# cart_x = seq(min(df1$amplitude), max(df1$amplitude), 0.01)
# cart_y = (cart_x^a) * exp(b)

cart_sd = abs(df1$duration - (df1$amplitude^a)*exp(b))

par(mfrow=c(1,2))
plot(df1$amplitude, cart_sd, xlim=c(0, 1))

# moving windows that take the median of the duration&#39;s sd over saccade amplitude
sd_change &amp;lt;- rollapply(cart_sd, width = 200, FUN = median, fill = NA)
plot(df1$amplitude, sd_change, xlim=c(0, 1))
df1$sd_duration &amp;lt;- sd_change

# regression of the duration sd over amplitude
var.model &amp;lt;- lm(sd_duration ~ amplitude, data = df1)
curve_y &amp;lt;- predict(var.model, data.frame(amplitude=cart_x) )
lines(cart_x, curve_y, lwd=2, col=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-7-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sd_b &amp;lt;- var.model$coefficients[[1]]
sd_a &amp;lt;- var.model$coefficients[[2]]
var.model$coefficients
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## (Intercept)   amplitude 
##   0.5487717   3.5581414
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the previous plot, it seems that a linear increase of SD with amplitude is a good approximation. However, we may not want the SD to diverge too much. Let us try with a model of variance that have a horizontal asymptote, for instance &lt;code&gt;1-exp(-amplitude)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df1$exp_amplitude &amp;lt;- (1-exp(-df1$amplitude))
var.model &amp;lt;- lm(sd_duration ~ exp_amplitude, data = df1)

var.model$coefficients
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##   (Intercept) exp_amplitude 
##      0.285162      5.240037
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sd_eb &amp;lt;- var.model$coefficients[[1]]
sd_ea &amp;lt;- var.model$coefficients[[2]]
# we do the prediction ourselve:
# we used SD.Duration = a * [1-exp(-amplitude)] + b, which gives:
curve_y &amp;lt;- (sd_ea + sd_eb) - sd_ea*exp(-cart_x)

plot(df1$amplitude, sd_change, xlim=c(0, 1))
lines(cart_x, curve_y, lwd=2, col=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-8-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A asymptotic equation seems to approximate the SD as well as the linear equation.&lt;/p&gt;

&lt;p&gt;To judge which is best, let us plot both the equations we estimated against the regression model we made earlier. Note that the regression model was showing a 95% prediction interval (in red), which depends on the SD that we formulated (in green and purple), but it is not expected to be equal to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot(df1$amplitude, df1$duration,
     main=&#39;df1&#39;, pch=&#39;.&#39;)
# regression fit:
lines(exp(new$log_amplitude), exp(y_values[,1]), lwd=2, col=&#39;red&#39;)
lines(exp(new$log_amplitude), exp(y_values[,2]), lwd=2, col=&#39;red&#39;)
lines(exp(new$log_amplitude), exp(y_values[,3]), lwd=2, col=&#39;red&#39;)

# our equations:
lines(cart_x, cart_y, lwd=2, col=&#39;green&#39;, lty=2)
## linear sd
sd_y = 0.55 + 3.54 * cart_x
lines(cart_x, cart_y+sd_y, lwd=2, col=&#39;green&#39;, lty=2)
lines(cart_x, cart_y-sd_y, lwd=2, col=&#39;green&#39;, lty=2)
## assymtotic sd:
sd_y = (sd_ea + sd_eb) - sd_ea*exp(-cart_x)
lines(cart_x, cart_y+sd_y, lwd=2, col=&#39;purple&#39;, lty=2)
lines(cart_x, cart_y-sd_y, lwd=2, col=&#39;purple&#39;, lty=2)
legend(&#39;bottomright&#39;, legend=c(&#39;regresssion&#39;, &#39;linear SD equation&#39;, &#39;assymptotic SD equation&#39;),lty=1, col=c(&#39;red&#39;, &#39;green&#39;, &#39;purple&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-9-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It seems that the assymptotic equation of SD do a better job than the linear equation. Furthermore, it is a wished property that the SD does not diverge. Thus, to summarize, our full model of the duration of saccade according to duration should follows: &lt;!-- remember that:
cart_y = (cart_x^a) * exp(b)
sd_y = (sd_ea + sd_eb) - sd_ea*exp(-cart_x)
--&gt;&lt;/p&gt;

&lt;p&gt;$$
E(Duration) \approx Amplitude^{0.51} \times exp(3.05) \&lt;br /&gt;
$$
$$
SD(Duration) \approx 5.53 - 3.56 exp(-Amplitude) \&lt;br /&gt;
$$&lt;/p&gt;

&lt;!-- SD(Duration) = 0.55 + 3.54.Amp
    E(Duration) = Amp^0.51 * exp(3.05)
--&gt;

&lt;h3 id=&#34;implement-a-stochastic-generator&#34;&gt;Implement a Stochastic Generator&lt;/h3&gt;

&lt;p&gt;Let us try to generate data from these equations .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;getADuration &amp;lt;- function(amp, n){
  mean.Duration = (amp^a) * exp(b)
  SD.Duration = (sd_ea + sd_eb) - sd_ea * exp(-amp)
  return(rnorm(length(mean.Duration)*n, mean.Duration, SD.Duration))
}

amp_space &amp;lt;- runif(5000, min=min(df1$amplitude), max=1)
gen.duration &amp;lt;- getADuration(amp_space, 1)

red_col = rgb(200,100,100,50,maxColorValue=255)
plot(df1$amplitude, df1$duration, ylim= c(4, 30), xlim=c(0, 1.2))
points(amp_space, gen.duration, ylim = c(4, 30), xlim=c(0, 1.2), col=red_col)
legend(&amp;quot;bottomright&amp;quot;, c(&#39;extracted data&#39;, &#39;model&#39;), col=c(&#39;black&#39;, red_col), pch=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nodragem.github.io/Blog/Blog/img/research/analyseExtractedData_files/unnamed-chunk-10-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We got a pretty cool stuff from a poor quality jpeg! We can, in fact, predict the durations of the saccade for amplitudes that Troconso et al. did not mesure. Now I am ready to use this saccade duration generator in my model of visuo-oculomotor movements :D.&lt;/p&gt;

&lt;p&gt;Hope this post was helpful, and see you soon!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
